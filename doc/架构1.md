### 1. **任务理解与分解阶段**

#### 1.1 任务描述和目标

用户输入任务描述（User Description）和目标（Target）。使用大型语言模型（LLM）进行自然语言理解与推理，解析用户意图并确定任务的整体目标。LLM需要根据上下文分析任务目标，识别其中的关键步骤、目标区域、执行条件等，输出一个明确的任务描述。

#### 1.2 任务分解

LLM将任务分解为多个子任务（SubTask）。每个子任务由一系列的基本指令（Instruction）组成，这些指令可以映射到特定的无人机动作。任务分解过程中需要根据目标与实际环境（如地图、传感器、无人机能力等）进行优化，确保每个子任务的可执行性与执行效率。

- **子任务生成**：将复杂的任务划分为更细化的步骤，明确每个子任务的目标、优先级、执行条件。
- **步骤生成**：每个子任务由一系列无人机的步骤组成，根据子任务的需求生成步骤
- **指令生成**：根据动作生成一系列基本指令。

#### 1.3 任务与指令关系

每个子任务的执行都与一个或多个指令对应。指令有固定的格式和参数要求，执行时需要进行校验，确保每个指令按顺序执行，并根据传感器返回的反馈（例如目标识别或飞行状态）进行动态调整。

子任务属性：

| 名称         | 描述         | 范围      |
| ------------ | ------------ | --------- |
| id           | 任务ID       |           |
| name         | 任务名称     |           |
| priority     | 优先级       | 0-10      |
| depId        | 依赖任务ID   | 任务ID    |
| isInterrupt  | 是否抢占     | 0/1       |
| state        | 任务状态     | 1,2,3,4,5 |
| device       | 使用的无人机 |           |
| instructions | 指令列表     | 列表      |
| requirements | 要求字典     | 字典      |

基本指令（Instruction）：

共同参数：当前无人机的命名空间（namespace）

| 指令名            | 功能                                 | 参数                         | 示例                                          |
| ----------------- | ------------------------------------ | ---------------------------- | --------------------------------------------- |
| control           | 启动无人机                           |                              | python control.py namespace                   |
| command_pos       | 飞行到位置（x,y,z）                  | 坐标x,y,z                    | python command_pos.py namespace x y z         |
| command_vel       | 以某个速度（x,y,z）飞行时间t         | 三个方向的速度x,y,z，时间t   | python command_vel.py namespace x y z t       |
| command_hover     | 悬停在当前位置，持续时间t            | 悬停时间t                    | python command_hover.py namespace t           |
| command_twist     | 围绕z轴以速度rate旋转角度degree      | 旋转角度degree，旋转速度rate | python command_twist.py namespace degree rate |
| command_land      | 降落到当前位置                       |                              | python command_land.py namespace              |
| command_search    | 在半径为r的圆形区域内搜索，持续时间t | 半径r，持续时间t             | python command_search.py namespace r t        |
| command_interrupt | 中断当前任务                         |                              |                                               |
| command_sensor    | 对传感器数据处理                     |                              |                                               |

无人机：

| id   | name | capability | is_available |
| ---- | ---- | ---------- | ------------ |



### 2. **任务调度与分配阶段**

#### 2.1 任务调度引擎

任务调度引擎的核心功能是对任务进行优先级调度，并根据无人机的资源、能力以及任务间的依赖关系进行合理的任务分配。

- **优先队列**：所有的子任务会添加到队列内进行排队。

- **优先级调度**：高优先级任务会优先执行，低优先级任务在队列中等待。任务调度引擎根据任务的优先级对队列中的任务进行排序。
- **抢占机制**：如果新的任务优先级更高，且该任务要求抢占，任务调度引擎会打断当前执行的任务，抢占资源。任务调度分为两种：
  - **抢占后恢复**：当前任务暂停，等高优先级抢占任务完成后，恢复现场继续执行。
  - **抢占后清空**：当前任务中断并清除队列，不再继续执行，系统等待新的任务调度。

#### 2.2 任务状态

任务状态包括以下几种：

- **待执行**：任务已经被分配给无人机，但尚未开始执行。
- **执行中**：任务正在执行，可能会被中断或暂停。
- **已完成**：任务执行完成。
- **已中断**：任务被高优先级任务中断。
- **等待中**：任务处于依赖或等待资源状态，未开始执行。

#### 2.3 任务依赖与同步

任务之间可能存在依赖关系。子任务可能依赖于其他子任务的完成，任务调度引擎需要在调度时考虑这些依赖，确保任务按顺序执行。如果某个任务依赖其他任务的完成，它的状态会被标记为“等待中”，直到前置任务完成或满足条件。

#### 2.4 任务与无人机匹配

任务与无人机是一对一、一对多，多对一，多对多的关系，任务调度引擎需要根据以下几个因素进行匹配：

- **无人机能力与任务需求**：根据无人机的载重、传感器、飞行范围、飞行时间等与任务的要求进行匹配。例如，某些任务可能需要长时间飞行或执行精准操作。
- **任务的优先级**：高优先级任务需要被优先分配给合适的无人机，避免低优先级任务阻碍高优先级任务的执行。
- **任务依赖关系**：确保任务的执行顺序正确，避免出现因依赖问题导致的执行冲突。

**匹配的时机：**子任务加入队列后，以及新任务加入队列，或者有任务执行完成

#### 2.5 多无人机协作

在任务分配过程中，多个子任务可能需要多个无人机协作。例如，若任务需要同时探查多个区域，多个无人机可以并行执行这些子任务。任务调度引擎需要确保任务的并行性，不会产生资源冲突。

### 3. **任务执行阶段**

#### 3.1 指令队列

每个子任务包含一系列指令，指令队列会按照执行顺序依次执行。每台无人机会对应着一个指令队列。每条指令都会执行特定的操作，如飞行、悬停、旋转等。每条指令执行时，系统需要：

- **检查指令成功执行**：系统会根据传感器数据来检查每条指令的执行是否符合预期。如果传感器反馈与预期不符，则指令需要重新执行或调整。
- **指令结果反馈**：如果某个指令的执行结果与预期不符（例如无人机无法飞到指定位置），任务引擎会决定是继续执行下一条指令还是返回并重新尝试当前指令。

#### 3.2 传感器与反馈

对于一些依赖传感器反馈的任务（例如目标识别、环境监测等），任务执行过程中需要实时获取传感器数据。系统需要：

- **实时监控传感器数据**：根据传感器返回的数据，判断任务是否完成或执行是否符合预期。
- **动态调整任务执行**：根据传感器数据，调整任务执行的顺序或策略。例如，若目标被检测到，任务可以提前结束或跳过某些步骤。

#### 3.3 异常处理与容错

在任务执行过程中，可能出现异常情况（如传感器故障、无人机失控等）。系统应具备容错机制，能够根据异常情况进行调整：

- **任务失败重试机制**：如果某条指令执行失败，可以尝试重新执行指令。

### 4. **任务恢复与清理**

#### 4.1 任务恢复

当任务执行过程中发生抢占，或者任务被中断，系统需要记录当前的任务状态和执行进度。任务恢复机制可以根据任务的执行进度恢复到中断前的状态。

#### 4.2 任务清理

完成或中断的任务需要进行清理，确保系统资源的回收。清理包括：

- **释放无人机资源**：完成任务或中断任务后，及时释放与任务相关的无人机资源。
- **更新任务状态**：将已完成或已中断的任务状态更新，供后续任务调度使用。

### 5. **总体流程**

1. **任务输入**：用户通过输入任务描述与目标，LLM将任务转化为具体的任务。
2. **任务分解与指令生成**：LLM根据任务目标和场景，将任务分解为多个子任务，并为每个子任务生成指令序列。
3. **任务调度与分配**：根据任务的优先级、依赖关系和无人机能力，任务调度引擎将任务分配给无人机，并处理优先级调度、抢占与并行执行。
4. **任务执行**：执行引擎按顺序执行每个指令，并根据传感器反馈调整任务执行。
5. **任务监控与恢复**：实时监控任务执行状态，根据反馈调整任务执行。必要时进行任务恢复与清理。



**任务调度器：**

1.将所有的任务放入优先级队列，根据优先级排队

2.管理任务之间的依赖关系，保证没有依赖任务或者依赖任务已经完成的任务才能执行

3.管理任务的状态

4.存储无人机和任务列表，将二者根据能力和需求进行匹配



**任务执行器：**

1.对于可执行的任务，执行任务的指令序列

2.执行基本指令

3.任务的中断与恢复



例子：

### Subtask 1: 起飞并到达楼顶

| 步骤   | 指令名        | 功能                          | 参数      | 示例                                    |
| ------ | ------------- | ----------------------------- | --------- | --------------------------------------- |
| Step 1 | control       | 启动无人机                    | 无        | `python control.py namespace`           |
| Step 2 | command_pos   | 飞行到楼顶的坐标位置（x,y,z） | 坐标x,y,z | `python command_pos.py namespace x y z` |
| Step 3 | command_hover | 悬停在楼顶的预定高度          | 悬停时间t | `python command_hover.py namespace t`   |

### Subtask 2: 探查楼顶是否有特定物体

| 步骤   | 指令名         | 功能                         | 参数             | 示例                                     |
| ------ | -------------- | ---------------------------- | ---------------- | ---------------------------------------- |
| Step 1 | command_search | 激活图像识别传感器进行搜索   | 半径r，持续时间t | `python command_search.py namespace r t` |
| Step 2 | command_search | 扫描楼顶区域并寻找特定物体   | 半径r，持续时间t | `python command_search.py namespace r t` |
| Step 3 | temp.py        | 如果发现物体，记录并返回数据 | 半径r，持续时间t | `python temp.py namespace r t`           |

### Subtask 3: 处理袭击规避

| 步骤   | 指令名      | 功能                                   | 参数             | 示例                                      |
| ------ | ----------- | -------------------------------------- | ---------------- | ----------------------------------------- |
| Step 1 | temp.py     | 监测环境并判断是否有袭击迹象           | 速度x,y,z，时间t | `python temp.py namespace x y z t`        |
| Step 2 | command_pos | 如果检测到风险，发出飞离指令并暂时避开 | 坐标x,y,z        | `python command_pos.py namespace x y z`   |
| Step 3 | command_vel | 飞离楼顶，调整飞行高度和方向以躲避袭击 | 速度x,y,z，时间t | `python command_vel.py namespace x y z t` |

### Subtask 4: 继续探查楼顶

| 步骤   | 指令名         | 功能                         | 参数             | 示例                                     |
| ------ | -------------- | ---------------------------- | ---------------- | ---------------------------------------- |
| Step 1 | command_pos    | 确认环境安全后，返回楼顶     | 坐标x,y,z        | `python command_pos.py namespace x y z`  |
| Step 2 | command_search | 返回楼顶并重新激活探查设备   | 半径r，持续时间t | `python command_search.py namespace r t` |
| Step 3 | command_search | 进行剩余的检查，确保没有遗漏 | 半径r，持续时间t | `python command_search.py namespace r t` |

### Subtask 5: 返回起飞点

| 步骤   | 指令名       | 功能                         | 参数             | 示例                                      |
| ------ | ------------ | ---------------------------- | ---------------- | ----------------------------------------- |
| Step 1 | command_pos  | 发出返回起飞点的指令         | 坐标x,y,z        | `python command_pos.py namespace x y z`   |
| Step 2 | command_vel  | 沿最优路径返回，监测飞行状态 | 速度x,y,z，时间t | `python command_vel.py namespace x y z t` |
| Step 3 | command_land | 安全降落在起飞点             | 无               | `python command_land.py namespace`        |



用户给出一个对于任务的描述和任务的目的，然后通过任务规划器（Task-planner）对任务进行规划。任务规划器是通过LLM首先对任务进行理解，将任务分解为一些能够在单个无人机上执行的，相对独立的子任务，这些子任务需要有任务描述、优先级、依赖关系、任务需求。LLM分析子任务，子任务可以由一个或多个动作组成，再将这些动作转换为一些可执行的基本指令。

​		任务规划阶段后，我们得到子任务集合，以及每个子任务对应的指令序列集合，进入任务的分配调度执行阶段。

​		这里我们需要先给出一些可用的无人机设备，以及无人机上可以部署的软件能力库。子任务需要依靠于无人机执行，因此首先，需要将子任务与无人机设备进行匹配，子任务有任务的描述和任务的需求，无人机也具有自己的能力，可以通过LLM判断某个无人机是否满足子任务的需求，进而进行配对（可能有死锁问题）。当子任务与无人机配对后，还要根据子任务的需求，在软件能力库中选择合适的模型部署到无人机上。如果资源没有得到满足，则任务进入等待中状态，等待资源的分配。最后得到了子任务、无人机和软件能力这样一个子任务执行的单位。

​		这里子任务与无人机可能是多对多的关系，但是我们限制只能是单无人机执行单子任务或者多子任务。如果多无人机执行单子任务，多无人机之间的指令可能也需要同步关系，因此在任务分解阶段，就将任务分解为只在单无人机上执行的子任务，这样就避免了这个问题。

​		接着，我们需要对子任务为单位（子任务，指令，无人机，软件能力）的一个执行集合进行调度与管理。

​		首先明确子任务的状态：待执行：任务已经被分配给无人机，但尚未开始执行。执行中：任务正在执行，可能会被中断或暂停。已完成：任务执行完成。已中断：任务被高优先级任务中断。等待中：任务处于依赖或等待资源状态，未开始执行。

​		由于子任务具有不同的优先级，因此将子任务加入到优先级队列（加入队列的任务的资源已经得到满足），进入待执行状态，根据优先级执行。同时由于子任务之间存在着相互的依赖关系，子任务会构成一个有向无环图，我们会选择没有依赖或者依赖已经得到满足的子任务进行执行，子任务变为执行中状态。由于进入执行中状态的子任务，没有依赖且资源被满足，这些子任务是可以并行执行的，所以启动多个线程分别对各自子任务的指令进行执行。

​		在每个执行中的子任务，与无人机是一对一的关系，只需要将指令队列中的的指令顺序执行（多个子任务可能是一台无人机，不是说后续无关子任务还可能分配到这台无人机，而是有些子任务的实现是需要指令的连续性，因此必须分配到一台无人机）。

​		当队列内的指令执行完成，这个子任务也就进入已完成状态，需要将子任务的一些中间结果传给对应的其他子任务或者系统，然后将子任务占用的资源进行释放，其他子任务在每次有子任务完成后，检测是否能够满足资源的分配以及是否能够满足依赖关系，如果满足资源的要求，就可以将子任务加入到子任务队列内，进入待执行状态；如果满足依赖关系，就可以进入到执行中状态，进行指令的执行。

​		此外，系统中会出现突发子任务，也就是要求中断其他的子任务并且优先级高。当外部发布突发子任务之后，系统接收子任务，判断子任务的优先级与当前子任务的优先级，以及子任务的中断请求和是否清空请求。如果中断，子任务执行器会中断当前子任务，并记录当前子任务的指令执行情况（应该也要记录无人机状态，例如位置等），然后立即执行中断子任务。如果要求清空，则直接清空子任务队列和所有等待的任务。否则，在这个子任务执行之后，恢复到发生中断时的状态。
